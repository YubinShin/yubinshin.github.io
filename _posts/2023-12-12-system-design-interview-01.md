---
title: 사용자 수에 따른 규모 확장성
date: 2023-12-12
categories: [blog]
tags: [book]
---


![https://contents.kyobobook.co.kr/sih/fit-in/458x0/pdt/9788966263158.jpg](https://contents.kyobobook.co.kr/sih/fit-in/458x0/pdt/9788966263158.jpg)

이번 장에서는 규모 확장성과 관련된 설계 지식을 알 수 있다.

## 단일 서버 

> 천 리 길도 한 걸음 부터

웹앱, DB, 캐시 등이 전부 서버 한 대에서 실행 된다.

## 웹 모바일 트래픽 서버 / 데이터베이스 서버 분리

사용자가 늘면 서버 하나로는 충분하지 않아서 여러 서버를 두어야한다.

웹 계층과 데이터 계층을 분리하면 그 각각을 독립적으로 확장해 나갈 수 있게 된다.

> No SQL 이 바람직한 경우
>
> - 아주 낮은 응답 지연시간(latency)가 요구됨.
> - 다루는 데이터가 비정형(unstructured)이라 관계형 데이터가 아님
> - 데이터를 **직렬화** 하거나 **역직렬화** 할 수 있기만 하면 됨.
> - 아주 많은 양의 데이터를 저장할 필요가 있음 (빅데이터)

- 직렬화(Serialized)
자바 개발에 최적화된 자바 고유 기술. 클래스, 인터페이스 등 자바만의 객체들을 별다른 작업 없이 외부로 export, import 할 수 있게 해준다.

## 수직적 규모 확장

Scale up, Vertical Scaling 
- 서버로 유입되는 트래픽의 양이 적을 때 - 좋은 방식
- 단순함 
- 한계가 있음. 한대에 서버에 cpu랑 메모리를 무한대로 붙일 순 없잖아요 
- 장애에 대한 자동복구 방안이나 다중화 방한을 제시하지 않는다. 서버에 장애가 발생하면 앱이 완전히 중단된다.

## 수평적 규모 확장

### 웹서버 로드 밸런서 

서버를 여러 개 띄워놓고 로드밸런싱 알고리즘을 이용해 적절하게 트래픽을 분산해서 보내준다.

예를 들어 임영웅 콘서트를 예매하는 것 처럼 엄청난 양의 사용자가 몰려드는 경우, 서버가 하나만 있다면 처리 용량을 넘어 섰을 때 서버가 멈춰버린다.

   <div style="width: 80%;">
      <img src="https://yubinshin.s3.ap-northeast-2.amazonaws.com/2023-12-12-system-design-interview-01/mono.png" alt="단일 서버">
   </div>

하지만 로드밸런서가 있다면 우아하게 돌아가는 서버에 부하를 나누거나 새로운 서버를 추가해서 가용성(availability)을 향상할 수 있다. 

   <div style="width: 80%;">
      <img src="https://yubinshin.s3.ap-northeast-2.amazonaws.com/2023-12-12-system-design-interview-01/loadbalance.gif" alt="로드밸런서">
   </div>

- [ ] 하드웨어 로드밸런서 : 전용 장비로 대규모 트래픽을 분산시킨다.
  
- [x] 소프트웨어 로드밸런서 : 가상화 환경에서 가상 ip 주소, 포트 포워딩, 세션 관리 등으로 로드 밸런싱


### 데이터베이스 다중화

Master - Slave 로 데이터베이스 서버 간 관계를 설정해둔다.

쓰기 연산은 Master DB에서만 진행하고, Slave DB 에서는 그 사본을 전달받아 읽기 연산만 처리한다.

대부분의 앱은 읽기 요청 비중이 훨씬 높기 때문에 Slave DB의 갯수가 훨씬 많다.

이렇게 DB를 다중화 하면 아래와 같은 장점이 있다.

1. 병렬로 처리할 수 있는 쿼리의 수가 늘어나므로 **성능**이 좋아진다.
2. 자연 재해등의 이유로 DB 중 일부가 파괴되어도 데이터는 보존될 것이다. 다른 장소에 백업해둘 수 있으니까 **안정성**이 높아진다.
3. 데이터를 여러 지역에 복제해둠으로써 하나의 DB서버에 장애가 발생해도 다른 서버에 있는 데이터를 가져와 계속 서비스하면 되니까 **가용성**이 높아진다.

혹시나 Master DB가 다운되면 원래 있던 Slave DB가 승진한다. 그리고 새로운 서버를 추가하면 된다. 부 서버에 있던 데이터가 최신이 아닐 수 있기 때문에 **복구 스크립트**를 돌려 추가 하면 된다. (다중 마스터나 원형 다중화 방식을 도입하면 도움이 될 수 있으나 훨씬 복잡하기때문에 따로 찾아보길 바란다.)

## 응답시간 줄이기 

###  캐시

캐시란, 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 두고, 뒤 이은 요청이 보다 빨리 처리될 수 있도록 하는 저장소이다. 

앱의 성능은 통상 DB를 얼마나 자주 호출하느냐에 크기 좌우되는데, 캐시를 사용하면 그런 문제를 크게 완화할 수 있다.(아래 동영상을 보면 캐싱 모듈 적용 전후로 21ms 에서 3ms 로 응답 시간이 줄어드는 걸 볼 수 있다.)

<iframe width="573" height="322" src="https://www.youtube.com/embed/KXnkhWRCj40;" title="Nest.js Caching Tutorial in 15 Minutes (Redis + Unit Testing)" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>


#### 캐시 사용 시 유의 해야 할 점

1. 데이터 갱신은 자주 일어나지 않지만 참조는 빈번하게 일어난다면 캐시를 사용해볼만 하다.
2. 캐시는 캐시서버가 재시작되면 모든 데이터가 사라지기 때문에 중요한 정보는 여전히 지속적 저장소에 두어야한다.
3. 캐시 데이터의 만료 정책을 마련해 두어야한다. 만료 기간이 너무 짧으면 db를 너무 자주 읽게 되어서 곤란하고, 길면 원본 db와 차이가 날 가능성이 높아진다.
4. 일관성 유지에 신경을 써야한다. 일관성(consistency)란 DB 내 원본 데이터와 캐시 내 사본이 동일한지 여부다. 여러 지역에 걸쳐 시스템이 확장된다면 단일 트랜잭션으로 DB와 캐시를 갱신하는게 어려워진다. 필요 시 아래 논문을 참고 해보자.
[Scaling Memcache at Facebook
](https://research.facebook.com/publications/scaling-memcache-at-facebook/)
5. 캐시 서버가 앱의 **단일 장애 지점**이 되는 것을 피하기 위해 여러 지역에 걸쳐 캐시 서버를 분산 시켜야 한다.
6. 캐시 메모리의 크기를 적절히 정해야 한다. 메모리 크기가 너무 작으면 데이터가 너무 자주 밀려나 버려 성능이 떨어질 수 있다. 이를 막으려면 캐시 메모리를 과할당(overprovision)하는 것도 좋은 방법이다. 이 방법을 쓰면 갑자기 캐싱할 데이터가 늘어도 안심이다.
7. 캐시 데이터 방출 정책을 경우에 맞게 적용하자. LRU, LFU, FIFO 등이 있다. [참고 - 페이지 교체 알고리즘](https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EC%A7%80_%EA%B5%90%EC%B2%B4_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
